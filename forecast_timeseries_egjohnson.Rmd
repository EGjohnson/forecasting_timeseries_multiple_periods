---
title: "forecast_timeseries_egjohnson"
author: "Elizabeth"
date: "March 27, 2019"
output: pdf_document
---

```{r setup, include=FALSE}
# import data processing and forecasting libraries
.x <- c("data.table", "readr","printr","scales","magrittr","pipeR","lubridate","ggplot2",
        "knitr","anytime","tidyr","dplyr","TTR","forecast","imputeTS")
lapply(.x, library, character.only = T)
setwd("~/PetGit/forecast_timeseries_multiple_periods/")
```

```{r}
# read in data as character
tcdat <- fread("app_data.csv",colClasses=c("character"))
tcdat %>% head
```


```{r}
#change UNIX timestamp to actual date
#seconds since Jan 01 1970. (UTC)
#convert characters to numeric
library(tidyr)
tcdat %>% dplyr::mutate(begin_time=anytime(as.integer(begin_time))) %>% dplyr::mutate_if(is.character,as.numeric) -> tcdat
                                                                
tcdat %>% head
```


#Throughput peaks in the middle of the day - but only on weekdays
```{r}

ggplot(tcdat, aes(x = begin_time, y = throughput)) + 
  geom_line(size =0.1) +
  scale_x_datetime(breaks = date_breaks("1 day"), labels=date_format("%a \n %d",tz=Sys.timezone()))+
  theme_bw()
```


#On a weekday throughput typically peaks prior to noon then tapers off.
```{r}
tcdat %>% dplyr::filter(day(begin_time) ==26)->tc.plot

ggplot(tc.plot, aes(x = begin_time, y = throughput)) + 
  geom_line(size =0.1) +
  scale_x_datetime(breaks = date_breaks("1 hour"),labels=time_format("%a \n %d \n %H",tz=Sys.timezone()))+
  theme_bw()
```


# response time spikes on some weekdays
```{r}
ggplot(tcdat, aes(x = begin_time, y = average_response_time)) + 
  geom_line(size = 1) +
  scale_x_datetime(breaks = date_breaks("1 day"), labels=date_format("%a-%d",tz=Sys.timezone()))+
  theme_bw()
```
# relationship between throughput and average response time
```{r}
#response_curve <-lm(throughput ~ log(average_response_time),data=tcdat)
#response_curve <-nls(throughput ~ exp(a + b * average_response_time), data = tcdat, start = list(a = 0.1, b = 0.3))
```

# how response time impacts throughput
```{r}
#take log of both throughput and response time
tcdat %<>% mutate(log.response=log10(average_response_time),log.through=log10(throughput))
#create subset of data that has response time effect
tcdat.res<-tcdat %>% filter(log.response>2.5)
# estimate impact response has on throughput
res.impact.throughput.mod <-lm(log.through~ log.response,data=tcdat.res)
#plot model of responses impact on throughput
tcdat.res$predict.throughput<-predict(res.impact.throughput.mod,log.response=tcdat.res$log.response,data=tcdat.res)
ggplot(tcdat.res, aes(y=log.through, x =log.response)) + geom_point()+
  geom_point(size =0.5) +
  geom_line(color='red',aes(y=tcdat.res$predict.throughput,x=tcdat.res$log.response))
  theme_bw() 

```
# how throughput impacts response time (mostly random)
```{r}
#create subset of data that has response time effect
tcdat.res<-tcdat %>% filter(log.response<2.5)
# estimate impact response has on throughput
res.impact.throughput.mod <-lm(log.response~ log.through,data=tcdat.res)
#plot model of responses impact on throughput
tcdat.res$predict.response<-predict(res.impact.throughput.mod,log.through=tcdat.res$log.through,data=tcdat.res)
ggplot(tcdat.res, aes(x=log.through, y =log.response)) + geom_point()+
  geom_point(size =0.5) +
  geom_line(color='red',aes(y=tcdat.res$predict.response,x=tcdat.res$log.through))
  theme_bw() 
```



#subtract out throughput spikes caused by lagging responses and interpolate
```{r}
# #1. put an NA in throughput outlier/spikes
tcdat %<>% mutate(throughput=case_when(log.response > 2.5  ~ NA_real_ ,TRUE ~ log.response))
# #2. smooth out these by interpolation
tcdat$throughput<-na.interpolation(tcdat$throughput, option = "linear")
```


# Decompose Timeseries into a weekly period, a daily period, trend and random noise
```{r}
tcdat.ts <- forecast::msts(tcdat$throughput,seasonal.periods = c(24*60,24*60*7-1))
tcdat.ts %>% mstl(.) ->tcdat.mstl
tcdat.mstl %>% autoplot() + xlab("Week")
```

#Forecast time series using STL decomposition and ARIMA for trend and noise component
```{r}
# STL: local regression for decomposition of cyclic components
# non seasonal arima model for trend and noise component
# 4 autoregressive terms (p)
# 1 difference needed for stationarity (d)
# 1 lagged forecast errors terms (q)

#create model that describes  4 weeks of data
tcdat.ts %>%stlf(method='arima',level=c(80,95),h =24*60*7*4) ->ts.model
#use model to forecast out 4  weeks
the.forecast<-forecast(ts.model,robust=TRUE)
plot(the.forecast)
```

```{r}
checkresiduals(ts.model)
```


# create forecast dataframe 
```{r}
tcdat %>% mutate(begin_time2=begin_time+minutes(1)) %>%
filter(max(begin_time2)==begin_time2) %>% select(begin_time2) %>%
.$begin_time %>% as.character()->start.new.time.vec

forecast.date<-seq(from=ymd_hms(start.new.time.vec)+min(1),length.out=the.forecast$mean %>% length,by="1 min")
the.forecast %>% data.frame() %>% cbind(forecast.date) -> the.forecast
the.forecast %>% head
```


# adjust for end of daylight savings time (app usage should be shifted)
```{r}
# Sunday, November 5, 2017, 2:00:00 am clocks were turned backward 1 hour to 1:00am (US Canada)
# UTC does not change with a change of seasons 
# but usage pattern of app will shift according to local time change

# for example: post time change, the 8am UTC usage will look like previous 7am UTC usage during daylight savings time
# during daylight savings people were getting to work an hour earlier in UTC time

# ID daylight savings observations and adjust throughput predictions (fall back)
the.forecast %<>% mutate(dst=case_when(forecast.date<ymd_hms("2017-11-05 01:00:00")~"yes",TRUE ~ "no")) #identify saving days
the.forecast %>% filter(dst=="no" & month(forecast.date)==11 & day(forecast.date)==5 & hour(forecast.date)==1) -> fall.back.hr
the.forecast %>% filter(dst=="no") %>% mutate(forecast.date=ymd_hms(forecast.date,tz = "UTC")+60*60)->the.forecast.dst.shift
the.forecast.adj<-rbind(the.forecast %>% filter(dst=="yes"),fall.back.hr,the.forecast.dst.shift)

```


# plot adjusted forecast 
```{r}
#the.forecast.adj %>% mutate(wkd=weekdays.POSIXt(forecast.date)) %>% filter(!wkd %in% #c("Saturday","Sunday"))->the.forecast.adj.plot

the.forecast.adj %>% mutate(wkd=weekdays.POSIXt(forecast.date))->the.forecast.adj.plot

p1 <- ggplot(the.forecast.adj.plot, aes(forecast.date,Point.Forecast))+
    geom_line()+geom_ribbon(data=the.forecast.adj,aes(ymin=Lo.80,ymax=Hi.80),alpha=0.3)+
  scale_x_datetime(breaks = date_breaks("1 day"), labels=date_format("%b - %d",tz=Sys.timezone()))+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# create an alternate response timecourse via bootstrapping hours
tcdat$average_response_time 
p2<-ggplot(the.forecast.adj.plot,aes(forecast.date,average_response_time)) + geom_line()
```

```{r}
p1
```




```{r}


```

